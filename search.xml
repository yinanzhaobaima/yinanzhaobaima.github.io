<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EXEC]]></title>
    <url>%2F2019%2F05%2F13%2FEXEC%2F</url>
    <content type="text"><![CDATA[一、发现源码打开链接题目提示no sign 查看源代码发现这一行 1&lt;meta language=&apos;utf-8&apos; editor=&apos;vim&apos;&gt; 想到vim信息泄露，于是访问/.index.php.swp成功下载了源代码 注意index前面有一个点 . 使用命令 1vim -r index.php.swp 用vim编辑器打开该文件，读到源代码如下： 二、审计源码1.变量sign只有当变量sign已经设置且非空； 并且以变量sign为参数的check函数返回值为1 才不会显示“no sign” 2.check函数只有参数number的每一个字符的ASCII值都不在’1’’到’9’的ASCII值范围内； 并且满足$number == ‘11259375’ 函数才能返回1 要满足以上两个条件，易知可用十六进制绕过 11259375的十六进制为0xabcdef，同时也满足每一个ascii码也不再0-9的范围内 故构造payload为： ?sign=0xabcdef 3.其他1setcookie(&apos;auth&apos;,&apos;tcp tunnel is forbidden!&apos;); 易知：TCP被禁止不能用curl命令 1//echo $result; 易知：打印被注释掉，cmd命令执行后没有回显 123/*flag in flag233.php*/ 最前面的注释告诉了我们flag文件的名称，那么我们直接用nc命令把flag文件下过来 三、获得flag 在公网服务器的控制台上运行命令 1nc -u -l -p 55566 -u udp -l listen -p port 即：nc作为server端启动一个udp的端口55566进行监听 在服务器134.175.18.182的55566udp端口接收文件flag2333.php 在服务器控制台上读取到payload]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>nc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白总结sunday算法]]></title>
    <url>%2F2019%2F05%2F05%2F%E5%B0%8F%E7%99%BD%E6%80%BB%E7%BB%93sunday%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Sunday 算法是Daniel M.Sunday于1990 年提出的一种比 BM 算法搜索速度更快的算法。 Sunday 算法是最新的对 BM 算法进行了大幅 改进的算法，它采用BM 算法中的坏字符启发规则，和 BM 算法相比效率有了较大的提高， 在实践中得到了广泛使用，具有新颖性和代表性。 核心思想在匹配过程中，模式串并不被要求一定要从左向右进行比较还是从右向左进行匹配。它在发现不匹配时，算法能跳过尽可能多的字符以进行下一步的匹配，从而提高了匹配效率。 匹配原理关注字符串中参加匹配的最末位字符的下一位字符 该字符没有在模式串中出现： 直接跳过模式串对应的字符串和下一位字符 移动位数 = 模式串长度 + 1； 该字符在模式串中出现： 若出现多次，选择模式串中最右出现的那一个 移动位数 = 模式串长度 - 该字符出现的位置(从0开始从左至右) ​ = 模式串中该字符到尾部的距离 + 1 举例说明假定现在要在主串”substring searching”中查找模式串”search”且模式串从左向右进行匹配 刚开始时，把模式串与主串左边对齐： 结果发现在第2个字符处发现不匹配不匹配时关注字符串中参加匹配的最末位字符的下一位字符，即绿色字符 i 向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7 从 i 之后的那个字符（即字符n）开始下一步的匹配 发现第一个字符就不匹配 再看字符串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位 ，使两个’r’对齐 向右移动位数 = 模式串中的r 到模式串末尾的距离 + 1 = 2 + 1 =3​ = 模式串长度 - 3 = 6 - 3 = 3 匹配成功。 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int maxNum = 127;int shift[maxNum];int Sunday(const string&amp; T, const string&amp; P) &#123; int n = T.length(); int m = P.length(); // 默认值，移动m+1位 for(int i = 0; i &lt; maxNum; i++) &#123; shift[i] = m + 1; //cout&lt;&lt;shift[i]&lt;&lt;endl; &#125; // 模式串P中每个字母出现的最后的下标 // 所对应的主串参与匹配的最末位字符的下一位字符移动到该位，所需要的移动位数 for(int i = 0; i &lt; m; i++) &#123; shift[P[i]] = m - i; //cout&lt;&lt;P[i]&lt;&lt;&quot;;&quot;&lt;&lt;shift[P[i]]&lt;&lt;&quot;;&quot;&lt;&lt;shift[73]&lt;&lt;&quot;;&quot;&lt;&lt;shift[115]&lt;&lt;endl; &#125; // 模式串开始位置在主串的哪里 int s = 0; // 模式串已经匹配到的位置 int j; while(s &lt;= n - m) &#123; j = 0; while(T[s + j] == P[j]) &#123; j++; // 匹配成功 if(j &gt;= m) &#123; return s; &#125; &#125; // 找到主串中当前跟模式串匹配的最末字符的下一个字符 // 在模式串中出现最后的位置 // 所需要从(模式串末尾+1)移动到该位置的步数 s += shift[T[s + m]]; cout &lt;&lt; s+m&lt;&lt;&quot;;&quot;&lt;&lt;T[s+m]&lt;&lt;&quot;;&quot;&lt;&lt;shift[T[s + m]]&lt;&lt;endl; &#125; return -1;&#125;int main() &#123; // 主串和模式串 string T, P; while(true) &#123; // 获取一行 getline(cin, T); getline(cin, P); int res = Sunday(T, P); if(res == -1) &#123; cout &lt;&lt; &quot;主串和模式串不匹配。&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;模式串在主串的位置为：&quot; &lt;&lt; res &lt;&lt; endl; &#125; &#125; return 0;&#125; ​ 优缺点看上去简单高效非常美好的Sunday算法，也有一些缺点。 因为Sunday算法的核心依赖于shift数组，而shift数组的值则取决于模式串，那么就可能存在一种模式串，会构造出很差的shift数组。 字符串：baaaabaaaabaaaabaaaa模式串：aaaaaa 这个模式串使得每次匹配失败时，只让模式串向后移动一位再进行匹配。这样就让Sunday算法的时间复杂度飙升到字符串匹配的最坏情况。 当然，也不能因为存在最坏的情况就直接否定Sunday算法。 大多数情况下，Sunday算法简单易懂，思维跳出常规匹配的想法，从概率上来说，其效率在匹配随机的字符串时比其他匹配算法还要更快。 参考网址： https://blog.csdn.net/q547550831/article/details/51860017 https://www.jianshu.com/p/2e6eb7386cd3]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[i春秋文件上传实验总结]]></title>
    <url>%2F2019%2F05%2F03%2Fi%E6%98%A5%E7%A7%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参考网址：https://blog.csdn.net/xiaotaode2012/article/details/77234535 一、本地验证如何判断是本地验证呢？很多情况下感觉速度较快的返回信息则认为有可能是本地验证，但是有的时候需要根据抓报以及跟踪上传代码来分析出是否为本地验证。 删除验证方法绕过上传打开firebug，将光标选择上传模块。 onsubm:t=”return checkFile()”是他的验证的框架，我们选中这一行，将它删除并编辑保存。 验证框架的代码进行删除之后，页面不会对我们上传文件的类型进行检测。 再重新选择yijuhua.php进行上传。 文件已经上传成功，保存在upload/yijuhua 将他复制到地址的后面，这个地址就是我们WEBSshell的连接地址。 修改过滤白名单绕过前台基于JS的验证打开Firebug查看代码，可以看到限制语句，可以判断为js前端验证。 在Firebug中修改JS代码绕过本地验证上传WEBShell。单击Firebug中的编辑功能，修改或者在类型后面加上PHP，让JS代码允许上传PHP文件。 上传WEBShell，提示上传成功，并返回路径。 二、服务器端验证 伪装type绕过MIME检测MIME客户端软件，区分不同种类的数据，例如web浏览器就是通过MIME类型来判断文件是GIF图片，还是可打印的PostScript文件。 web服务器使用MIME来说明发送数据的种类， web客户端使用MIME来说明希望接收到的数据种类。 MIME检测原理服务端MIME类型检测是通过检查http包的Content-Type字段中的值来判断上传文件是否合法的。 我们可以伪装上传文件的type值，来绕过服务端的MIME检测 修改文件扩展名绕过文件拓展名检测 若后缀名不是php 利用后缀名大小写混用绕过、利用空格或者加点的方式绕过 若后缀名是php，可改为php2，php3、php4、php5 php语言除了可以解析以php为后缀的文件，还可以解析php2，php3、php4、php5这些后缀的文件 修改文件内容绕过文件内容检测上传PHP文件，发现提示错误为The File Is Not Picture,因此得出结论，PHP文件被禁止上传。 服务器断可能是通过文件类型进行判断的，于是我们将yijuhua.php的改为yijuhua.jpg，进行上传尝试，发现也没有上传成功，所以我们可以判断：服务器端是通过文件内容进行验证的。 我们再将正常的图片文件上传一次，返回查看被截断的数据包，在末尾加上几个空格后粘贴一句话，然后修改文件名的尾缀为.php利于之后使用中国菜刀进行连接。 空格的作用主要用于隔开图片文件和一句话，避免一句话解析混乱。 利用00截断绕过上传限制点击上传抓到包之后，可以看到，filename 后面即是我们当前上传的路径，uploading则是保存在服务器上的地址。 现在我们将uploadimg改为uploadimg/1.php .jpg ，接着我们来到 Proxy-&gt;intercept-&gt;Hex找到1.php .jpg这个被修改过的代码，找到同一行的数字20，改为00 按一下回车，返回。 注意 ：20(空格字符的16进制)改成00(截断字符的16进制）这样以来。截断字符后面的都会被截断，也就是忽略掉了，所以uploadimg/1.php .jpg 就变成了uploadimg/1.php 达到了我们上传PHP文件的目的。 返回Raw，看到uploadimg/1.php .jpg变成uploadimg/1.php□.jpg 至此为止：原本的文件服务器保存路径从uploadimg/yijuhua.jpg变为uploadimg/1.php。 iis6.0目录解析漏洞（asp）上传ASP文件，发现提示错误信息：White List Match Failed–asp ,可能服务器端禁止了尾缀asp的文件上传。 查看数据包：其中Content-Disposition:form-data;name=”path”下面的一行为服务保存文件的相对路径，我们把原本的 1uploading/ 改为 1uploading/1.asp/ 再将 1filename=&quot;yijuhua.asp&quot; 改为 123filename=&quot;yijuhua.jpg&quot;或filename=&quot;yijuhua.asp/1.jpg&quot; IIS6.0目录路径检测解析： 如果文件的名字为“*.asp/xxx.jpg”，则会被 IIS 当作 ASP文件来解析并执行 例：如果请求 /aaa.asp/xxxx.jpg IIS会从头部查找查找 “.”号,获得 .asp/xxxx.jpg 再查找”/“,如果有则内存截断，所以/aaa.asp/xxxx.jpg会当做/aaa.asp进行解析 菜刀连接： http://www.test.ichunqiu/uploadimg/1.php/1563548665.jpg 新生成的目录在uploadimg目录下； 新生成的文件在新生成的目录下。 iis6.0文件名解析漏洞（php）查看数据包,其中Content-Disposition:form-data;name=”path”下面的一行为服务保存文件的相对路径。 把原本的 1uploadimg/ 改为 1uploadimg/1.php; 再把 1filename=&quot;yijuhua.php&quot; 改为 1filename=&quot;yijuhua.jpg&quot; IIS6.0目录路径检测解析： 如果文件的名字为“*.php;xxx.jpg”，则会被 IIS 当作 PHP 文件来解析并执行 例：如果请求 /aaa.php;xxx.jpg IIS会从头部查找查找 .号，获得 .php;xxx.jpg 再查找 ; 号，如果有则内存截断，所以/aaa.php;xxx.jpg会当做/aaa.php进行解析 菜刀连接： http://www.test.ichunqiu/uploadimg/1.php;1538707354.jpg 新生成的目录和文件同在uploadimg目录下 利用Apache白名单解析缺陷绕过上传检测将 yijuhua.php文件名加上后缀名为.7z。 7z格式是一种压缩文件的格式，但Apache不识别7z后缀，Apache解析文件时，如果后缀名不认识，则会继续向前解析，会解析到php，这就是Apache的解析漏洞。 利用.htaccess文件绕过上传检测编写.htaccess文件 打开记事本，将如下代码写入文本中： 1AddType application/x-httpd-php .jpg 然后点击文件选中另存为，编写文件名为.htaccess，选择保存类型为所有文件。 .htaccess文件里的代码的含义 是 将上传的文件后缀名为.jpg格式的文件以 php格式来解析文件。将.htaccess文件进行上传,上传成功。 .htaccess是apache服务器中的一个配置文件,不是上传的文件的黑名单之内 ,所以.htaccess文件是可以上传成功。 把一句话文件的后缀名为yijuhua.php改为后缀名为jpg格式 。 上传成功到服务器的.htaccess文件里的代码可以让 .jpg后缀名文件格式的文件名以 php格式解析 所以我们把yijuhua.php文件的后缀名改为.jpg格式,让.htaccess文件解析 yijuhua.jpg文件里的php代码 ,使木马上传成功。 菜刀连接：www.test.com/uploadimg/yijuhua.jpg FCK编辑器查看版本信息1/_samples/default.html 打开编辑器页面，点击“？”图标(鼠标放在问号图标上面点击问号图片)可以在关于中查看到编辑器的版本信息 1/_whatsnew.html 访问这个地址可以查看FCK当前版本和历史版本，第一个显示的是当前版本 不同版本上传地址FCK2.4.2 1editor/filemanager/browser/default/connectors/test.html 1/editor/filemanager/upload/test.html FCK2.6.6 1/editor/filemanager/connectors/test.html 1/editor/filemanager/connectors/uploadtest.html IIS解析原理:Windows 2003 IIS6 存在着文件解析路径的漏洞，当文件夹名为类似**.asp结尾的目录名的时候（即文件夹名看起来像一个ASP文件的文件名），此时此文件夹下的任何类型的文件都可以在IIS中被当做ASP程序来执行。这样黑客即可上传扩展名为.jpg或.gif之类的看起来像是图片文件的木马文件，通过访问这个文件即可运行木马。比如 1.asp/a.jpg 由上可知：如果可以控制上传文件夹路径,那么不管你上传后你的图片改不改名，都能拿shell了 首先点击Create Folder(创建文件夹)新建一个文件夹名为1.asp点击确定 然后在Current Folder(当前文件夹)里面输入刚刚建立的文件夹名字1.asp，设置好文件保存路径,保存到1.asp文件夹里,把一句话（yijuhua.asp)的后缀换成.jpg,然后上传,从而绕过上传验证。 Current Folder(当前文件夹)把创建好的1.asp文件夹目录中，再创建一个2.asp的文件夹(因为不创建2.asp的文件夹1.asp的文件夹是不能使用的，所以要创建2.asp文件夹才可以使用，此版本漏洞的特性就是这样)。 创建好后2.asp系统把1.asp文件夹自动生成出来然后1.asp的文件夹才可以使用，在上传(yijuhua.jpg)木马。 点击 Current Folder(当前文件夹)设置好目录保存文件路径1.asp上传(yijuhua.jpg)返回File uploaded with no errors(没有错误上传的文件)上传成功。 看到url=”/userfiles/file/1.asp/”文件夹下的上传成功后,组合一个新的网址,先把文件夹路径给复制下来,然后复制上传后的一句话文件名，然后组合文件夹路径： 1/userfiles/file/1.asp/ Shell最终地址为： 1www.test.com/userfiles/file/1.asp/yijuhua.jpg]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>WEB安全</tag>
        <tag>文件上传</tag>
        <tag>i春秋</tag>
      </tags>
  </entry>
</search>
